{"mappings":"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","sources":["<anon>","node_modules/viem/_esm/utils/ccip.js","node_modules/viem/utils/ccip.ts","node_modules/viem/_esm/errors/ccip.js","node_modules/viem/errors/ccip.ts","node_modules/viem/_esm/utils/address/isAddressEqual.js","node_modules/viem/utils/address/isAddressEqual.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire3018\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"d36sf\", function(module, exports) {\n\n$parcel$export(module.exports, \"offchainLookupSignature\", () => $98008feb734aebcf$export$630379c2aa400f99);\n$parcel$export(module.exports, \"offchainLookup\", () => $98008feb734aebcf$export$d6522c9964119b53);\n\nvar $5UENw = parcelRequire(\"5UENw\");\n\n\nvar $hGzrH = parcelRequire(\"hGzrH\");\n\nvar $5pGkz = parcelRequire(\"5pGkz\");\n\nvar $exqIB = parcelRequire(\"exqIB\");\n\nvar $e9Gwc = parcelRequire(\"e9Gwc\");\n\nvar $1tfJf = parcelRequire(\"1tfJf\");\n\nvar $kTOx8 = parcelRequire(\"kTOx8\");\n\nvar $01CEa = parcelRequire(\"01CEa\");\n\nvar $41CuJ = parcelRequire(\"41CuJ\");\nconst $98008feb734aebcf$export$630379c2aa400f99 = \"0x556f1830\";\nconst $98008feb734aebcf$export$eec6ee9dde8e502e = {\n    name: \"OffchainLookup\",\n    type: \"error\",\n    inputs: [\n        {\n            name: \"sender\",\n            type: \"address\"\n        },\n        {\n            name: \"urls\",\n            type: \"string[]\"\n        },\n        {\n            name: \"callData\",\n            type: \"bytes\"\n        },\n        {\n            name: \"callbackFunction\",\n            type: \"bytes4\"\n        },\n        {\n            name: \"extraData\",\n            type: \"bytes\"\n        }\n    ]\n};\nasync function $98008feb734aebcf$export$d6522c9964119b53(client, { blockNumber: blockNumber, blockTag: blockTag, data: data, to: to }) {\n    const { args: args } = (0, $exqIB.decodeErrorResult)({\n        data: data,\n        abi: [\n            $98008feb734aebcf$export$eec6ee9dde8e502e\n        ]\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    try {\n        if (!(0, $1tfJf.isAddressEqual)(to, sender)) throw new (0, $hGzrH.OffchainLookupSenderMismatchError)({\n            sender: sender,\n            to: to\n        });\n        const result = await $98008feb734aebcf$export$aa421b8052670ca4({\n            data: callData,\n            sender: sender,\n            urls: urls\n        });\n        const { data: data_ } = await (0, $5UENw.call)(client, {\n            blockNumber: blockNumber,\n            blockTag: blockTag,\n            data: (0, $kTOx8.concat)([\n                callbackSelector,\n                (0, $e9Gwc.encodeAbiParameters)([\n                    {\n                        type: \"bytes\"\n                    },\n                    {\n                        type: \"bytes\"\n                    }\n                ], [\n                    result,\n                    extraData\n                ])\n            ]),\n            to: to\n        });\n        return data_;\n    } catch (err) {\n        throw new (0, $hGzrH.OffchainLookupError)({\n            callbackSelector: callbackSelector,\n            cause: err,\n            data: data,\n            extraData: extraData,\n            sender: sender,\n            urls: urls\n        });\n    }\n}\nasync function $98008feb734aebcf$export$aa421b8052670ca4({ data: data, sender: sender, urls: urls }) {\n    let error = new Error(\"An unknown error occurred.\");\n    for(let i = 0; i < urls.length; i++){\n        const url = urls[i];\n        const method = url.includes(\"{data}\") ? \"GET\" : \"POST\";\n        const body = method === \"POST\" ? {\n            data: data,\n            sender: sender\n        } : undefined;\n        try {\n            const response = await fetch(url.replace(\"{sender}\", sender).replace(\"{data}\", data), {\n                body: JSON.stringify(body),\n                method: method\n            });\n            let result;\n            if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) result = (await response.json()).data;\n            else result = await response.text();\n            if (!response.ok) {\n                error = new (0, $5pGkz.HttpRequestError)({\n                    body: body,\n                    details: result?.error ? (0, $41CuJ.stringify)(result.error) : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url: url\n                });\n                continue;\n            }\n            if (!(0, $01CEa.isHex)(result)) {\n                error = new (0, $hGzrH.OffchainLookupResponseMalformedError)({\n                    result: result,\n                    url: url\n                });\n                continue;\n            }\n            return result;\n        } catch (err) {\n            error = new (0, $5pGkz.HttpRequestError)({\n                body: body,\n                details: err.message,\n                url: url\n            });\n        }\n    }\n    throw error;\n}\n\n});\nparcelRegister(\"hGzrH\", function(module, exports) {\n\n$parcel$export(module.exports, \"OffchainLookupError\", () => $ce01daae27a87e61$export$e655df38b41a5462);\n$parcel$export(module.exports, \"OffchainLookupResponseMalformedError\", () => $ce01daae27a87e61$export$a202e6f25b41683e);\n$parcel$export(module.exports, \"OffchainLookupSenderMismatchError\", () => $ce01daae27a87e61$export$f4e6b144b80c03db);\n\nvar $41CuJ = parcelRequire(\"41CuJ\");\n\nvar $hRZHI = parcelRequire(\"hRZHI\");\n\nvar $k9Ckd = parcelRequire(\"k9Ckd\");\nclass $ce01daae27a87e61$export$e655df38b41a5462 extends (0, $hRZHI.BaseError) {\n    constructor({ callbackSelector: callbackSelector, cause: cause, data: data, extraData: extraData, sender: sender, urls: urls }){\n        super(cause.shortMessage || \"An error occurred while fetching for an offchain result.\", {\n            cause: cause,\n            metaMessages: [\n                ...cause.metaMessages || [],\n                cause.metaMessages?.length ? \"\" : [],\n                \"Offchain Gateway Call:\",\n                urls && [\n                    \"  Gateway URL(s):\",\n                    ...urls.map((url)=>`    ${(0, $k9Ckd.getUrl)(url)}`)\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`\n            ].flat()\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"OffchainLookupError\"\n        });\n    }\n}\nclass $ce01daae27a87e61$export$a202e6f25b41683e extends (0, $hRZHI.BaseError) {\n    constructor({ result: result, url: url }){\n        super(\"Offchain gateway response is malformed. Response data must be a hex value.\", {\n            metaMessages: [\n                `Gateway URL: ${(0, $k9Ckd.getUrl)(url)}`,\n                `Response: ${(0, $41CuJ.stringify)(result)}`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"OffchainLookupResponseMalformedError\"\n        });\n    }\n}\nclass $ce01daae27a87e61$export$f4e6b144b80c03db extends (0, $hRZHI.BaseError) {\n    constructor({ sender: sender, to: to }){\n        super(\"Reverted sender address does not match target contract address (`to`).\", {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"OffchainLookupSenderMismatchError\"\n        });\n    }\n}\n\n});\n\nparcelRegister(\"1tfJf\", function(module, exports) {\n\n$parcel$export(module.exports, \"isAddressEqual\", () => $1124b344b520ec49$export$34ca016df7f376b8);\n\nvar $2VOm9 = parcelRequire(\"2VOm9\");\n\nvar $fCd4Y = parcelRequire(\"fCd4Y\");\nfunction $1124b344b520ec49$export$34ca016df7f376b8(a, b) {\n    if (!(0, $fCd4Y.isAddress)(a, {\n        strict: false\n    })) throw new (0, $2VOm9.InvalidAddressError)({\n        address: a\n    });\n    if (!(0, $fCd4Y.isAddress)(b, {\n        strict: false\n    })) throw new (0, $2VOm9.InvalidAddressError)({\n        address: b\n    });\n    return a.toLowerCase() === b.toLowerCase();\n}\n\n});\n\n\n\n//# sourceMappingURL=ccip.d2a038e2.js.map\n","import { call } from '../actions/public/call.js';\nimport {} from '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipFetch({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipFetch({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = ErrorType\n\nexport async function offchainLookup<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipFetchErrorType = ErrorType\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupError'\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupResponseMalformedError'\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupSenderMismatchError'\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a, { strict: false }))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b, { strict: false }))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$98008feb734aebcf$export$630379c2aa400f99","$98008feb734aebcf$export$d6522c9964119b53","$5UENw","$hGzrH","$5pGkz","$exqIB","$e9Gwc","$1tfJf","$kTOx8","$01CEa","$41CuJ","$98008feb734aebcf$export$eec6ee9dde8e502e","name","type","inputs","client","blockNumber","blockTag","data","to","args","decodeErrorResult","abi","sender","urls","callData","callbackSelector","extraData","isAddressEqual","OffchainLookupSenderMismatchError","result","$98008feb734aebcf$export$aa421b8052670ca4","data_","call","concat","encodeAbiParameters","err","OffchainLookupError","cause","error","Error","i","length","url","method","includes","body","undefined","response","fetch","replace","JSON","stringify","headers","startsWith","json","text","ok","HttpRequestError","details","statusText","status","isHex","OffchainLookupResponseMalformedError","message","$ce01daae27a87e61$export$e655df38b41a5462","$ce01daae27a87e61$export$a202e6f25b41683e","$ce01daae27a87e61$export$f4e6b144b80c03db","$hRZHI","$k9Ckd","BaseError","constructor","shortMessage","metaMessages","map","getUrl","flat","writable","value","$1124b344b520ec49$export$34ca016df7f376b8","$2VOm9","$fCd4Y","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase"],"version":3,"file":"ccip.d2a038e2.js.map"}